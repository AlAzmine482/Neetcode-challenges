
#1 Duplicate Integer:
class Solution:
    
    ex: nums: [1,2,3,3]
    create empty set    
    check for loop for duplicate and check set
    if x in set then return true else false
    
    def hasDuplicate(self, nums: List[int]) -> bool:
         seen = set()
         for x in nums:
            if x in seen:
                return True
            seen.add(x)
            return False

#2 Valid Anagram
class Solution:
        ex: s = racecar, t = carrace
        check length if not the same return false.
        for loop s then check the frequency of all letters.
def isAnagram(self, s: str, t: str) -> bool:
        
        if len(s) != len(t):
            return False

        countS, countT = {}, {}

        for i in range(len(s))
            countS[s[i]] = 1 + countS.get(s[i], 0)
            print(countS)


#3 Two Integer Sum

ex: Input: 
nums = [3,4,5,6], target = 7

Output: [0,1]

enumerate to get the index and values
create dictionary
prev = {}
for i, val in enumerate(num)
    diff = target - val
    if diff in prev:
       return [prev[r], i]
    prev = i


#4 anagram groups:


class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        res = {} #mapping character count of from list of anagrams 
        for s in strs:
            count = [0] * 26 #lowercase a-z
            for c in s:
                count[ord(c) - ord("a")]  += 1
                
            res[tuple(count)].append(s)

        return res.values()

#5 Products of Array Discluding Self

    Input: nums = [1,2,4,6]

    Output: [48,24,12,8]

    if is 1 return product of everything else
    ex: 1 product = 48 (2 x 4 x 6)

    go from last to beginning 

    class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        res = [1] * (len(nums)) #(length of nums)
        prefix = 1 #(index for prefix )
        
        for i in range(len(nums))
            res[i] = prefix #(updates index)
            prefix *= nums[I] #(prefix multiple nums[I] )
        postfix = 1
        for i in range(len(nums) -1, -1, -1): #(up to beginning)
            res[i] *= postfix
            postfix *= nums[i]
        return res


#6 Valid Palindrome

  checkv is initialized to an empty string and checks if its alpha numeric
and append each word to lowercase 
returning true or false with checkv word and inverse of checkv

  checkv = ""
        for each in s:
            if each.isalnum():
                checkv += each.lower()
        return checkv == checkv[::-1]


#7 Two Sum pointer
L is initialized at the end of the list. 
r is initialized at the beginning of the list.
We compare summation (numbers[l] + numbers[r]) to the target and decrease l  or increase r.
ex: Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].

 l, r=0, len(numbers) - 1
    
        while l < r: 
            if numbers[l] + numbers[r] == target: return (l + 1, r + 1)
            if numbers[l] + numbers[r] > target: r-=1
            else: l+=2


#8 3sum
class Solution:

Input: nums = [-1,0,1,2,-1,-4]

Output: [[-1,-1,2],[-1,0,1]]

enumerate both nums have 2 pointers for left and right of nums;
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()

        for i, a in enumerate(nums)
            if i > 0 and a == nums[i-1]:
                continue

            l, r = i + 1, lens(nums) - 1
            while l < r:
                threesum = a + nums[l] + nums[r]
                if threesum > 0:
                    r -= 1
                elif threesum < 0:
                    l += 1
                else: 
                    res.append([a, nums[l], nums[r]])
                    l += 1
                    while nums[l] == nums[l -1] and l < r:
                        l+= 1
            return res
                
            
